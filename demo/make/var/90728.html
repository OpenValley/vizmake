<!DOCTYPE html>
<html>
  <head>
		<title>Visualizing Makefile -- Variable View</title>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
    <script type="text/javascript" src="http://d3js.org/d3.v2.min.js?2.9.6"></script>
    <script type="text/javascript" src="http://code.jquery.com/jquery-1.8.2.min.js"></script>

		<style>
			.node rect {
			cursor: pointer;
			fill: #fff;
			fill-opacity: .5;
			stroke: #3182bd;
			stroke-width: 1.5px;
			}

			.node text {
			font: 10px sans-serif;
			pointer-events: none;
			}

			path.link {
			fill: none;
			stroke: #9ecae1;
			stroke-width: 1.5px;
			}

			div.tooltip {
			position: absolute;
			text-align: left;
			width: 300px;
			height:250px;
			padding: 8px;
			font: 11px sans-serif;
			background: #ffff99;
			border: solid 1px #aaa;
			border-radius: 8px;
			pointer-events: none;
			}
		</style>
	</head>
	<body>
		<div id="chart"></div>
		<script>
		var w = 960,
    h = 10000,
    i = 0,
    barHeight = 20,
    barWidth = w * .8,
    duration = 400,
    root;

		var tree = d3.layout.tree()
    .size([h, 100]);

		var diagonal = d3.svg.diagonal()
    .projection(function(d) { return [d.y, d.x]; });

		var vis = d3.select("#chart").append("svg:svg")
    .attr("width", w)
    .attr("height", h)
		.append("svg:g")
    .attr("transform", "translate(20,30)");

		d3.json("90728.json", function(json) {
		json.x0 = 0;
		json.y0 = 0;
		update(root = json);
		});

		var div = d3.select("body").append("div")
    .attr("class", "tooltip")
    .style("opacity", 1e-6);


		function update(source) {

		// Compute the flattened node list. TODO use d3.layout.hierarchy.
		var nodes = tree.nodes(root);
		
		// Compute the "layout".
		nodes.forEach(function(n, i) {
    n.x = i * barHeight;
		});
		
		// Update the nodes…
		var node = vis.selectAll("g.node")
    .data(nodes, function(d) { return d.id || (d.id = ++i); });
		
		var nodeEnter = node.enter().append("svg:g")
    .attr("class", "node")
    .attr("transform", function(d) { return "translate(" + source.y0 + "," + source.x0 + ")"; })
    .style("opacity", 1e-6);

		// Enter any new nodes at the parent's previous position.
		nodeEnter.append("svg:rect")
    .attr("y", -barHeight / 2)
    .attr("height", barHeight)
    .attr("width", barWidth)
    .style("fill", color)
    .on("click", click)
		.on("mouseover", mouseover)
		.on("mousemove", mousemove)
		.on("mouseout", mouseout);
		
		nodeEnter.append("svg:text")
    .attr("dy", 3.5)
    .attr("dx", 5.5)
    .text(function(d) { return d.name; });
		
		// Transition nodes to their new position.
		nodeEnter.transition()
    .duration(duration)
    .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; })
    .style("opacity", 1);
		
		node.transition()
    .duration(duration)
    .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; })
    .style("opacity", 1)
		.select("rect")
    .style("fill", color);
		
		// Transition exiting nodes to the parent's new position.
		node.exit().transition()
    .duration(duration)
    .attr("transform", function(d) { return "translate(" + source.y + "," + source.x + ")"; })
    .style("opacity", 1e-6)
    .remove();
		
		// Update the links…
		var link = vis.selectAll("path.link")
    .data(tree.links(nodes), function(d) { return d.target.id; });
		
		// Enter any new links at the parent's previous position.
		link.enter().insert("svg:path", "g")
    .attr("class", "link")
    .attr("d", function(d) {
    var o = {x: source.x0, y: source.y0};
    return diagonal({source: o, target: o});
    })
    .transition()
    .duration(duration)
    .attr("d", diagonal);
		
		// Transition links to their new position.
		link.transition()
    .duration(duration)
    .attr("d", diagonal);
		
		// Transition exiting nodes to the parent's new position.
		link.exit().transition()
    .duration(duration)
    .attr("d", function(d) {
    var o = {x: source.x, y: source.y};
    return diagonal({source: o, target: o});
    })
    .remove();
		
		// Stash the old positions for transition.
		nodes.forEach(function(d) {
    d.x0 = d.x;
    d.y0 = d.y;
		});
		}

		// Toggle children on click.
		function click(d) {
		if (d.children) {
    d._children = d.children;
    d.children = null;
		} else {
    d.children = d._children;
    d._children = null;
		}
		update(d);
		}

		function mouseover(d) {
		if (d.tooltip == "NO") return;
		if (d.type == "LINE" || d.type == "VAR") {
		div.transition()
		.duration(300)
		.style("opacity", 1);
		}
		}

		function mousemove(d) {
		if (d.tooltip == "NO") return;
		var string = "";
		if (d.type == "LINE") {
		string += "Full CONTENT OF THIS LINE ===> "
		} else if (d.type == "VAR") {
		string += "EXPANDED VALUE OF THIS VARIABLE ===> "
		} else {
		return;
		}

		string += d.full;
    div.text(string)
    .style("left", (d3.event.pageX ) + "px")
    .style("top", (d3.event.pageY) + "px");
		}

		function mouseout(d) {
		if (d.tooltip == "NO") return;
		if (d.type == "LINE" || d.type == "VAR") {
		div.transition()
		.duration(300)
		.style("opacity", 1e-6);
		}
		}

		function color(d) {
		if (d.type == "FILE") return "#3182bd";
		else if (d.type == "LINE") return "#fd8d3c";
		else if (d.type == "VAR") return "#c6dbef";
		return "#FFFFFF";
		}
		</script>
	</body>
</html>
