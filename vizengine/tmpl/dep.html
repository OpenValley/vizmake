<!DOCTYPE html>
<html>
  <head>
		<title>Visualizing Makefile -- Variable View</title>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
    <script type="text/javascript" src="../../lib/jquery.js"></script>
    <script type="text/javascript" src="../../lib/d3.js"></script>


		<style>
			.node rect {
			cursor: pointer;
			fill: #fff;
			fill-opacity: .5;
			stroke: #3182bd;
			stroke-width: 1.5px;
			}

			.node text {
			font: 10px sans-serif;
			pointer-events: none;
			}

			path.link {
			fill: none;
			stroke: #9ecae1;
			stroke-width: 1.5px;
			}

		</style>
	</head>
	<body>
		<div id="chart"></div>
		<script>
			var w = 960,
			h = $$CANVAS_HEIGHT$$,
			i = 0,
			barHeight = 20,
			barWidth = w * .8,
			duration = 400,
			root;

			var tree = d3.layout.tree()
			.size([h, 100]);

			var diagonal = d3.svg.diagonal()
			.projection(function(d) { return [d.y, d.x]; });

			var vis = d3.select("#chart").append("svg:svg")
			.attr("width", w)
			.attr("height", h)
			.append("svg:g")
			.attr("transform", "translate(20,30)");

			d3.json("$$PID_VALUE$$.json", function(json) {
			json.x0 = 0;
			json.y0 = 0;
			update(root = json);
			});

			

			function update(source) {

			// Compute the flattened node list. TODO use d3.layout.hierarchy.
			var nodes = tree.nodes(root);
			
			// Compute the "layout".
			nodes.forEach(function(n, i) {
			n.x = i * barHeight;
			});
			
			// Update the nodes…
			var node = vis.selectAll("g.node")
			.data(nodes, function(d) { return d.id || (d.id = ++i); });
			
			var nodeEnter = node.enter().append("svg:g")
			.attr("class", "node")
			.attr("transform", function(d) { return "translate(" + source.y0 + "," + source.x0 + ")"; })
			.style("opacity", 1e-6);

			// Enter any new nodes at the parent's previous position.
			nodeEnter.append("svg:rect")
			.attr("y", -barHeight / 2)
			.attr("height", barHeight)
			.attr("width", barWidth)
			.style("fill", color)
			.on("click", click)
			.on("mouseover", mouseover)
			.on("mouseout", mouseout);
			
			nodeEnter.append("svg:text")
			.attr("dy", 3.5)
			.attr("dx", 5.5)
			.text(function(d) { return d.name; });
			
			// Transition nodes to their new position.
			nodeEnter.transition()
			.duration(duration)
			.attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; })
			.style("opacity", 1);
			
			node.transition()
			.duration(duration)
			.attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; })
			.style("opacity", 1)
			.select("rect")
			.style("fill", color);
			
			// Transition exiting nodes to the parent's new position.
			node.exit().transition()
			.duration(duration)
			.attr("transform", function(d) { return "translate(" + source.y + "," + source.x + ")"; })
			.style("opacity", 1e-6)
			.remove();
			
			// Update the links…
			var link = vis.selectAll("path.link")
			.data(tree.links(nodes), function(d) { return d.target.id; });
			
			// Enter any new links at the parent's previous position.
			link.enter().insert("svg:path", "g")
			.attr("class", "link")
			.attr("d", function(d) {
			var o = {x: source.x0, y: source.y0};
			return diagonal({source: o, target: o});
			})
			.transition()
			.duration(duration)
			.attr("d", diagonal);
			
			// Transition links to their new position.
			link.transition()
			.duration(duration)
			.attr("d", diagonal);
			
			// Transition exiting nodes to the parent's new position.
			link.exit().transition()
			.duration(duration)
			.attr("d", function(d) {
			var o = {x: source.x, y: source.y};
			return diagonal({source: o, target: o});
			})
			.remove();
			
			// Stash the old positions for transition.
			nodes.forEach(function(d) {
			d.x0 = d.x;
			d.y0 = d.y;
			});
			}

			// Toggle children on click.
			function click(d) {
			if (d.children) {
			d._children = d.children;
			d.children = null;
			} else {
			d.children = d._children;
			d._children = null;
			}
			update(d);
			}

			function mouseover(d) {
			if (d.tooltip == "NO") return;
			if (d.type == "TARGET") {
			var string = "";
			var elems = d.cmd.split("\n");
			string += elems[0];
			for (var i = 1; i < elems.length; i++ ) {
        string += "<p>";
        string += elems[i];													
        string += "</p>";
			}
			$("#details", window.parent.frames["details"].document).html(string);

			}
			}

			function mouseout(d) {
			if (d.type == "TARGET") {
			// $("#details", window.parent.frames["details"].document).html("");
			}
			}

			function color(d) {
			if (d.type == "PROC") return "#3182bd";
			else if (d.type == "TARGET") return "#fd8d3c";
			else if (d.type == "MFILE") return "#FA5882";
			else if (d.type == "EFILE") return "#F3F781";
			else if (d.type == "CFILE") return "#A9F5A9";
			return "#FFFFFF";
			}
		</script>
	</body>
</html>
